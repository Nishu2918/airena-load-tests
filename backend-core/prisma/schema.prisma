// Prisma Schema for GCC FUSION Hackathon Platform
// Database: SQLite (for testing)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================
// Note: SQLite doesn't support enums, using String instead

model User {
  id            String      @id @default(uuid())
  email         String      @unique
  passwordHash  String
  firstName     String
  lastName      String
  role          String      @default("PARTICIPANT") // UserRole: PARTICIPANT, ORGANIZER, JUDGE, ADMIN
  status        String      @default("PENDING_VERIFICATION") // UserStatus: ACTIVE, INACTIVE, SUSPENDED, PENDING_VERIFICATION
  avatarUrl     String?
  bio           String?
  githubUrl     String?
  linkedinUrl   String?
  portfolioUrl  String?
  
  // Relations
  teams         TeamMember[]
  organizedHackathons Hackathon[] @relation("HackathonOrganizer")
  submissions   Submission[]
  reviews       Review[]
  notifications Notification[]
  auditLogs     AuditLog[]
  hackathonParticipants HackathonParticipant[]
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  lastLoginAt   DateTime?
  
  @@index([email])
  @@index([role])
  @@index([status])
}

// ============================================
// HACKATHON MANAGEMENT
// ============================================
// Note: SQLite doesn't support enums, using String instead

model Hackathon {
  id                String            @id @default(uuid())
  title             String
  description       String            // SQLite doesn't need @db.Text
  category          String            // HackathonCategory: WEB_DEVELOPMENT, MOBILE_DEVELOPMENT, AI_ML, etc.
  status            String            @default("DRAFT") // HackathonStatus: DRAFT, PUBLISHED, etc.
  
  // Organizer
  organizerId       String
  organizer         User              @relation("HackathonOrganizer", fields: [organizerId], references: [id])
  
  // Dates
  registrationStart DateTime
  registrationEnd   DateTime
  startDate         DateTime
  endDate           DateTime
  submissionDeadline DateTime
  
  // Prize & Requirements
  prizeAmount       Float?
  prizeCurrency     String?           @default("USD")
  registrationFee   Float?            // Optional registration fee
  requirements      String            // JSON stored as String: Structured requirements for AI matching
  
  // Rules & Guidelines
  rules             String            // SQLite doesn't need @db.Text
  guidelines        String            // SQLite doesn't need @db.Text
  
  // Media
  bannerImageUrl    String?
  logoImageUrl      String?
  
  // Team Settings
  minTeamSize       Int               @default(1)
  maxTeamSize       Int               @default(5)
  allowIndividual   Boolean           @default(true)
  
  // Relations
  teams             Team[]
  submissions       Submission[]
  notifications     Notification[]
  participants      HackathonParticipant[]
  
  // Timestamps
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  publishedAt       DateTime?
  
  @@index([organizerId])
  @@index([status])
  @@index([category])
  @@index([startDate])
}

// ============================================
// TEAM MANAGEMENT
// ============================================
// Note: SQLite doesn't support enums, using String instead

model Team {
  id            String        @id @default(uuid())
  name          String
  hackathonId   String
  hackathon     Hackathon     @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  status        String        @default("PENDING") // TeamStatus: PENDING, ACTIVE, DISBANDED
  
  // Relations
  members       TeamMember[]
  submissions   Submission[]
  
  // Timestamps
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@unique([hackathonId, name])
  @@index([hackathonId])
  @@index([status])
}

// Note: SQLite doesn't support enums, using String instead

model TeamMember {
  id            String            @id @default(uuid())
  teamId        String
  team          Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId        String
  user          User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          String            @default("MEMBER") // TeamMemberRole: LEADER, MEMBER
  status        String            @default("PENDING") // TeamMemberStatus: PENDING, ACCEPTED, REJECTED
  
  // Timestamps
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  
  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

// ============================================
// SUBMISSION MANAGEMENT
// ============================================
// Note: SQLite doesn't support enums, using String instead

model Submission {
  id                String            @id @default(uuid())
  hackathonId       String
  hackathon         Hackathon         @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  // Submitter
  submitterId       String
  submitter         User              @relation(fields: [submitterId], references: [id])
  
  // Team (if team submission)
  teamId            String?
  team              Team?             @relation(fields: [teamId], references: [id])
  type              String            // SubmissionType: INDIVIDUAL, TEAM
  
  // Submission Content
  title             String
  description       String            // SQLite doesn't need @db.Text
  repositoryUrl     String?
  liveUrl           String?
  videoUrl          String?
  presentationUrl   String?
  files             String            // JSON stored as String: Array of S3 file URLs
  
  // Status & Lifecycle
  status            String            @default("DRAFT") // SubmissionStatus: DRAFT, SUBMITTED, etc.
  isDraft           Boolean           @default(true)
  isFinal           Boolean           @default(false)
  
  // AI Review Results
  aiReviewResult    String?           // JSON stored as String: AI Analyzer output
  aiMatchPercentage Float?
  aiDecision        String?           // PASS_TO_OFFLINE_REVIEW, NEEDS_IMPROVEMENT, REJECTED
  aiExplanation     String?           // SQLite doesn't need @db.Text
  
  // Offline Review Results
  reviews           Review[]
  finalScore        Float?
  rank              Int?
  
  // Relations
  notifications     Notification[]
  
  // Timestamps
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  submittedAt       DateTime?
  reviewedAt        DateTime?
  
  @@index([hackathonId])
  @@index([submitterId])
  @@index([teamId])
  @@index([status])
  @@index([isDraft])
}

// ============================================
// REVIEW MANAGEMENT
// ============================================
// Note: SQLite doesn't support enums, using String instead

model Review {
  id            String        @id @default(uuid())
  submissionId  String
  submission    Submission    @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  judgeId       String
  judge         User          @relation(fields: [judgeId], references: [id])
  
  // Scoring
  scores        String        // JSON stored as String: Criteria-based scores
  totalScore    Float
  comments      String?       // SQLite doesn't need @db.Text
  status        String        @default("PENDING") // ReviewStatus: PENDING, IN_PROGRESS, COMPLETED
  
  // Timestamps
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  completedAt   DateTime?
  
  @@unique([submissionId, judgeId])
  @@index([submissionId])
  @@index([judgeId])
  @@index([status])
}

// ============================================
// NOTIFICATIONS
// ============================================
// Note: SQLite doesn't support enums, using String instead

model Notification {
  id            String            @id @default(uuid())
  userId        String
  user          User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathonId   String?
  hackathon     Hackathon?        @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  submissionId  String?
  submission    Submission?       @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  
  type          String            // NotificationType: HACKATHON_PUBLISHED, REGISTRATION_OPEN, etc.
  title         String
  message       String            // SQLite doesn't need @db.Text
  status        String            @default("UNREAD") // NotificationStatus: UNREAD, READ, ARCHIVED
  metadata      String?           // JSON stored as String
  
  // Timestamps
  createdAt     DateTime          @default(now())
  readAt        DateTime?
  
  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
}

// ============================================
// ANALYTICS & AUDIT LOGS
// ============================================
// Note: SQLite doesn't support enums, using String instead

model AuditLog {
  id            String          @id @default(uuid())
  userId        String?
  user          User?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  action        String          // AuditLogAction: CREATE, UPDATE, DELETE, LOGIN, etc.
  entityType    String          // "Hackathon", "Submission", "Team", etc.
  entityId      String?
  changes       String?         // JSON stored as String
  ipAddress     String?
  userAgent     String?
  
  // Timestamps
  createdAt     DateTime        @default(now())
  
  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
}

// ============================================
// HACKATHON PARTICIPANT TRACKING
// ============================================

model HackathonParticipant {
  id          String   @id @default(uuid())
  hackathonId String
  userId      String
  joinedAt    DateTime @default(now())
  hackathon Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([hackathonId, userId])
  @@index([hackathonId])
  @@index([userId])
}

